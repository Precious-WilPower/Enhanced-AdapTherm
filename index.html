<!DOCTYPE html>
<html>
<head>
  <title>Adaptherm - Sensory Wheel</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f5f5f5;
      color: #333;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      overflow-x: hidden;
    }
    
    h1, h2, h3 {
      color: #1565c0;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 20px;
    }
    
    /* Tab styling */
    .tabs {
      display: flex;
      border-bottom: 1px solid #ccc;
      margin-bottom: 20px;
    }
    
    .tab-button {
      background: none;
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      font-size: 16px;
    }
    
    .tab-button.active {
      border-bottom: 3px solid #1565c0;
      font-weight: bold;
      color: #1565c0;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    /* Emergency panel with deep blue background */
    .emergency-panel {
      background-color: #1a3a5f; /* Deep blue color */
      color: white;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    
    .emergency-panel h3 {
      color: white;
      margin-top: 0;
    }
    
    .emergency-panel p {
      font-size: 15px;
      line-height: 1.4;
      margin-bottom: 8px;
      color: white;
    }
    
    /* Streamlined emergency panel layout */
    .symptom-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-bottom: 12px;
      max-width: 100%;
      justify-content: center;
    }
    
    .symptom-button {
      background-color: #ffffff;
      border: 1px solid #03a9f4;
      border-radius: 20px;
      padding: 6px 12px;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.2s;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      white-space: nowrap;
    }
    
    .symptom-button:hover {
      background-color: #e1f5fe;
      transform: translateY(-2px);
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    
    .symptom-button.active {
      background-color: #03a9f4;
      color: white;
      border-color: #0277bd;
    }
    
    /* Contained text entry */
    .custom-description {
      width: 90%;
      max-width: 600px;
      padding: 8px 12px;
      border: 2px solid #81d4fa;
      border-radius: 4px;
      margin: 5px auto 10px;
      font-family: inherit;
      resize: none;
      height: 36px;
      font-size: 14px;
      display: block;
    }
    
    .typing-indicator {
      font-size: 12px;
      color: #e1f5fe;
      margin-top: -5px;
      margin-bottom: 10px;
      visibility: hidden;
      text-align: left;
    }
    
    .typing-indicator.visible {
      visibility: visible;
    }
    
    .recommendations {
      background-color: #f8f9fa;
      border-radius: 4px;
      padding: 15px;
      border: 1px solid #e2e6ea;
      margin-bottom: 20px;
    }
    
    .emergency-panel .recommendations {
      background-color: #25517f;
      border-color: #1a3a5f;
    }
    
    .recommendations h4 {
      margin-top: 0;
      color: #343a40;
      font-size: 15px;
    }
    
    .emergency-panel .recommendations h4 {
      color: white;
    }
    
    .recommendations ul {
      padding-left: 20px;
    }
    
    .recommendations li {
      margin-bottom: 5px;
      line-height: 1.4;
    }
    
    .emergency-panel .recommendations li {
      color: white;
    }
    
    /* Sensory wheel container */
    .sensory-content {
      display: flex;
      flex-direction: row;
      flex-wrap: wrap;
      gap: 20px;
      justify-content: center;
    }
    
    .wheel-container {
      width: 500px;
      height: 500px;
      position: relative;
    }
    
    .sensory-wheel-svg {
      width: 100%;
      height: auto;
    }
    
    /* Clickable elements styling */
    .section-path {
      transition: all 0.2s;
      cursor: pointer;
    }
    
    .section-path:hover {
      filter: brightness(1.1);
      transform: scale(1.01);
      transform-origin: center;
    }
    
    .wheel-hub {
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .wheel-hub:hover {
      filter: brightness(1.1);
      transform: scale(1.05);
      transform-origin: center;
    }
    
    /* Enhanced spoke styling - major change to improve clickability */
    .spoke-clickable-area {
      stroke-width: 20px;
      stroke-opacity: 0.1;
      cursor: pointer;
      transition: stroke-opacity 0.2s;
    }
    
    .spoke-clickable-area:hover {
      stroke-opacity: 0.3;
    }
    
    .spoke {
      stroke-width: 2px;
      transition: stroke-width 0.2s;
    }
    
    .spoke-group:hover .spoke {
      stroke-width: 3px;
    }
    .spoke, .spoke-group {
  filter: none !important;
}
    /* Information panels - side-positioned and expandable */
    .info-panel {
      display: none;
      position: fixed;
      top: 10%;
      right: 10px;
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      z-index: 100;
      width: 35%;
      max-width: 400px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    .panel-expanded {
      width: 60%;
      max-width: 800px;
      height: 85vh;
      max-height: 85vh;
    }
    
    .info-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }
    
    .info-panel-controls {
      display: flex;
      gap: 10px;
    }
    
    .info-panel-title {
      margin: 0;
      color: #1565c0;
    }
    
    .close-panel, .expand-panel {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: #495057;
      width: 30px;
      height: 30px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      transition: background-color 0.2s;
    }
    
    .close-panel:hover, .expand-panel:hover {
      background-color: #f1f3f5;
    }
    
    .panel-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 90;
    }
    
    /* Chart container - expandable */
    .chart-container {
      height: 300px;
      margin: 20px 0;
      transition: height 0.3s;
    }
    
    .chart-container.expanded {
      height: 500px;
    }
    
    /* Trend info */
    .trend-info {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 15px;
    }
    
    .trend-card {
      flex: 1;
      min-width: 110px;
      background: #f8f9fa;
      border-radius: 8px;
      padding: 12px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    
    .trend-value {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .trend-label {
      color: #6c757d;
      font-size: 13px;
    }
    
    .trend-direction {
      display: flex;
      align-items: center;
      margin-top: 5px;
      font-weight: bold;
      font-size: 12px;
    }
    
    .trend-up {
      color: #28a745;
    }
    
    .trend-down {
      color: #dc3545;
    }
    
    /* Recommendations styling */
    .recommendations-list {
      margin-top: 15px;
    }
    
    .recommendation-item {
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 10px;
    }
    
    .recommendation-title {
      font-weight: bold;
      margin-bottom: 5px;
    }
    
    .recommendation-desc {
      color: #6c757d;
      margin-bottom: 10px;
    }
    
    .contact-options {
      margin-top: 20px;
    }
    
    .contact-title {
      font-weight: bold;
      margin-bottom: 10px;
    }
    
    .contact-list {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }
    
    .contact-button {
      background: #4a6fa5;
      color: white;
      border: none;
      border-radius: 20px;
      padding: 8px 15px;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .contact-button:hover {
      background: #395b89;
      transform: translateY(-2px);
    }
    
    .professional-button {
      background: #28a745;
    }
    
    .professional-button:hover {
      background: #218838;
    }
    
    /* Interactive sliders */
    .stability-slider-section h3 {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0px;
}

.stability-slider-section h3 .section-score {
  color: #1565c0;
  font-weight: bold;
}

.slider-row {
  width: 100%;
}

.slider-input {
  width: 100%;
  margin: 0px 0;
}

.variability-spectrum-info {
  display: flex;
  justify-content: space-between;
  margin-top: 0px;
  font-size: 12px;
  color: #666;
}

.variability-spectrum-info span {
  font-size: 12px;
  color: #666;
}

.variability-spectrum-info span:first-child {
  text-align: left;
}

.variability-spectrum-info span:last-child {
  text-align: right;
}

    .event-input-row {
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 15px;
      margin-bottom: 15px;
    }
    
    .event-input-row label {
      font-size: 15px;
      font-weight: bold;
    }
    
    .event-input {
      width: 70px;
      padding: 8px;
      border: 1px solid #ced4da;
      border-radius: 4px;
      text-align: center;
      font-size: 15px;
    }
    
    .calculate-btn, .apply-changes {
      background: #4a6fa5;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 10px 20px;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 16px;
      margin-top: 10px;
    }
    
    .apply-changes {
      display: block;
      width: 100%;
    }
    
    .calculate-btn:hover, .apply-changes:hover {
      background: #395b89;
      transform: translateY(-2px);
    }
    
    /* Individual Tab Styles */
    .score-display {
      background-color: #e3f2fd;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
    }
    
    .score-circle {
      width: 80px;
      height: 80px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      color: white;
      margin: 10px auto;
    }
    
    .score-label {
      font-weight: bold;
      margin-top: 10px;
    }
    
    /* Compact core metrics styling */
    .core-metrics-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 15px;
      justify-content: space-between;
    }
    
    .metric-box {
      flex: 1;
      min-width: 120px;
      max-width: 180px;
      background-color: #f8f9fa;
      border: 1px solid #e2e6ea;
      border-radius: 8px;
      padding: 8px;
    }
    
    .metric-box label {
      font-weight: bold;
      display: block;
      margin-bottom: 3px;
      font-size: 13px;
    }
    
    .metric-box input[type="range"] {
      width: 100%;
      margin: 3px 0;
    }
    
    .custom-metrics {
      margin-bottom: 15px;
    }
    
    .custom-metric {
      position: relative;
      margin-bottom: 10px;
    }
    
    .delete-metric {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: #f44336;
      color: white;
      border: none;
      width: 24px;
      height: 24px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-weight: bold;
    }
    
    .delete-metric:hover {
      background-color: #d32f2f;
    }
    
    .add-metric-form {
      background-color: #f0f7ff;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 15px;
    }
    
    .metric-input-group {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .metric-input-group input {
      flex: 3;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    
    .metric-input-group select {
      flex: 1;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }
    
    .add-metric-btn {
      background-color: #43a047;
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    
    .add-metric-btn:hover {
      background-color: #2e7d32;
    }
    
    .action-button {
      background-color: #1565c0;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
      margin: 15px 0;
    }
    
    .action-button:hover {
      background-color: #0d47a1;
    }
    
    .range-labels {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #666;
      margin-top: 5px;
    }
    
    /* Position gauge styling */
    .position-gauge {
      width: 100%;
      height: 40px;
      background: linear-gradient(to right, 
        #3f51b5 0%, /* Deep blue (hypo) */
        #2196f3 20%, /* Light blue */
        #4caf50 50%, /* Green (balanced) */
        #ffc107 80%, /* Yellow */
        #f44336 100% /* Red (hyper) */
      );
      border-radius: 15px;
      position: relative;
      margin: 15px 0;
    }
    
    .position-marker {
      position: absolute;
      top: -5px;
      width: 10px;
      height: 50px;
      background-color: #ffffff;
      border: 2px solid #333;
      border-radius: 3px;
      transform: translateX(-50%);
    }
    
    .position-labels {
      display: flex;
      justify-content: space-between;
      font-size: 14px;
      color: #495057;
      margin-top: 8px;
    }
    
    /* Research references button and panel */
    .research-references-btn {
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 20px;
      display: inline-block;
    }
    
    .research-references-btn:hover {
      background-color: #e9ecef;
    }
    
    .research-panel {
      display: none;
      margin-top: 10px;
      padding: 15px;
      background-color: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 4px;
    }
    
    .research-panel h4 {
      margin-top: 0;
      color: #495057;
    }
    
    .research-panel p {
      font-size: 14px;
      line-height: 1.5;
      color: #495057;
    }
    
    /* Hub panel expanded styles */
    #hub-panel.panel-expanded .stability-inputs {
      padding: 7px;
      margin-bottom: 5px;
    }
    
    #hub-panel.panel-expanded .stability-slider-section, 
    #hub-panel.panel-expanded .event-input-section {
      margin-bottom: 20px;
    }
    
    #hub-panel.panel-expanded .stability-slider-section h3 {font-size: 20px;
      margin-bottom: 5px;
    } 
    #hub-panel.panel-expanded .event-input-section h3 {
      font-size: 20px;
      margin-bottom: -2px;
    }
    
    #hub-panel.panel-expanded .slider-row {
      margin-bottom: 0px;
    }
    
    #hub-panel.panel-expanded .slider-label {
      width: 240px;
      font-size: 16px;
    }
    
    #hub-panel.panel-expanded .slider-value {
      font-size: 18px;
    }
    
    #hub-panel.panel-expanded .spectrum-info {
      margin-top: 0px;
      font-size: 14px;
    }
    
    /* Responsive layout */
    @media (max-width: 768px) {
      .sensory-content {
        flex-direction: column;
        align-items: center;
      }
      
      .wheel-container {
        width: 100%;
        max-width: 400px;
        height: auto;
      }
      
      .info-panel {
        width: 95%;
        max-width: 95%;
      }
      
      .core-metrics-row {
        flex-direction: column;
      }
      .stability-inputs {
  position: relative;
}

/* Position Value Styling */
.position-value-container {
  display: flex;
  justify-content: flex-end;
  align-items: center;
  margin-bottom: 10px;
}

.position-value {
  font-size: 36px;
  font-weight: bold;
  color: #1565c0;
  background-color: #f0f0f0;
  padding: 5px 15px;
  border-radius: 6px;
  margin-left: 15px;
}

/* Interactive Gradient Gauge */
.position-gauge {
  width: 100%;
  height: 30px;
  background: linear-gradient(to right, 
    #3f51b5 0%,   /* Deep blue (shutdown) */
    #2196f3 20%,  /* Light blue */
    #4caf50 50%,  /* Green (balanced) */
    #ffc107 80%,  /* Yellow */
    #f44336 100%  /* Red (meltdown) */
  );
  border-radius: 15px;
  position: relative;
  cursor: pointer;
}

.position-marker {
  position: absolute;
  top: -5px;
  width: 20px;
  height: 40px;
  background-color: white;
  border: 2px solid #333;
  border-radius: 4px;
  transform: translateX(-50%);
  transition: left 0.3s ease;
}

.position-labels {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: #666;
  margin-top: 5px;
}

/* Improved Variability Spectrum Info */
.variability-spectrum-info {
  display: flex;
  justify-content: space-between;
  margin-top: -5px;
  font-size: 11px;
  color: #666;
}

.variability-spectrum-info span:first-child {
  text-align: left;
}

.variability-spectrum-info span:last-child {
  text-align: right;
}



/* Improve slider appearance */
.slider-row {
  display: flex;
  align-items: center;
 
}

.slider-input {
  flex-grow: 1;
  margin: 0 5px;
}

.slider-value {
  width: 40px;
  text-align: center;
  font-size: 16px;
}

      
/* Make sure only intended elements appear on main page */
.sensory-content ~ .trend-info,
.sensory-content ~ .chart-container,
.sensory-content ~ .recommendations {
  display: none;
}

/* Ensure these elements are visible only in their proper panels */
#hub-panel .trend-info,
#hub-panel .chart-container,
#hub-panel #individualRecommendations {
  display: block;
}

/* Keep emergency panel visible */
.emergency-panel {
  display: block !important;
}

    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Adaptation Thermostat</h1>
    
    <!-- Simple tabbed interface -->
    <div class="tabs">
      <button class="tab-button active" onclick="openTab('sensory')">Sensory Adaptation</button>
      <button class="tab-button" onclick="openTab('individual')">Individual Level</button>
      <button class="tab-button" onclick="openTab('institutional')">Institutional Level</button>
      <button class="tab-button" onclick="openTab('uk-case')">UK Case Study</button>
    </div>
    
    <!-- Sensory tab content -->
    <div id="sensory" class="tab-content active">
      <!-- Emergency Panel - with deep blue background -->
      <div class="emergency-panel">
        <h3>Quick Help</h3>
        
        <p>Choose what you're experiencing:</p>
        <!-- Compact horizontal button layout -->
        <div class="symptom-buttons">
          <button class="symptom-button" data-system="visual">Vision Issues</button>
          <button class="symptom-button" data-system="auditory">Sound Sensitivity</button>
          <button class="symptom-button" data-system="vestibular">Dizziness</button>
          <button class="symptom-button" data-system="tactile">Touch Problems</button>
          <button class="symptom-button" data-system="smell">Smell Sensitivity</button>
          <button class="symptom-button" data-system="interoceptive">Body Signals</button>
          <button class="symptom-button" data-system="proprioceptive">Body Position</button>
          <button class="symptom-button" data-system="taste">Taste Issues</button>
        </div>
        
        <textarea class="custom-description" placeholder="Describe what you're feeling here..."></textarea>
        <div class="typing-indicator">Finding help for you...</div>
        
        <div class="recommendations" id="emergency-recommendations">
          <h4>Try these right now:</h4>
          <ul id="immediate-interventions">
            <li>Click a button above or describe what you're feeling</li>
          </ul>
        </div>
      </div>
      
      <!-- Sensory wheel and information area - properly centered -->
      <div class="sensory-content">
        <div class="wheel-container">
          <!-- SVG wheel with proper warning lines and clickable indicators -->
          <svg class="sensory-wheel-svg" viewBox="0 0 500 500" xmlns="http://www.w3.org/2000/svg">
            <!-- Outer circle border -->
            <circle cx="250" cy="250" r="241" fill="none" stroke="black" stroke-width="2"/>
            
            <!-- Colored sections in outer ring - each represents a sensory system -->
            <!-- Visual - Green (well-regulated) - Centered at 0° -->
            <path d="M155.5,28.8 A245,245 0 0,1 344.5,28.8 L319,92 A180,180 0 0,0 179.2,83.6 Z" 
                  fill="#a8d08d" stroke="none" class="section-path" id="visual-section" 
                  data-section="visual" onclick="showSectionInfo('visual')"/>
            
            <!-- Auditory - Yellow (moderately regulated) - Centered at 45° -->
            <path d="M344.5,28.8 A245,245 0 0,1 471.2,155.5 L412.4,179.2 A180,180 0 0,0 320.8,83.6 Z" 
                  fill="#ffe699" stroke="none" class="section-path" id="auditory-section" 
                  data-section="auditory" onclick="showSectionInfo('auditory')"/>
            
            <!-- Vestibular - Green (well-regulated) - Centered at 90° -->
            <path d="M471.2,155.5 A245,245 0 0,1 471.2,344.5 L412.4,320.8 A180,180 0 0,0 412.4,179.2 Z" 
                  fill="#a8d08d" stroke="none" class="section-path" id="vestibular-section" 
                  data-section="vestibular" onclick="showSectionInfo('vestibular')"/>
            
            <!-- Proprioceptive - Yellow (moderately regulated) - Centered at 135° -->
            <path d="M471.2,344.5 A245,245 0 0,1 344.5,471.2 L320.8,412.4 A180,180 0 0,0 412.4,320.8 Z" 
                  fill="#ffe699" stroke="none" class="section-path" id="proprioceptive-section" 
                  data-section="proprioceptive" onclick="showSectionInfo('proprioceptive')"/>
            
            <!-- Interoceptive - Red (poorly regulated) - Centered at 180° -->
            <path d="M344.5,471.2 A245,245 0 0,1 155.5,471.2 L179.2,412.4 A180,180 0 0,0 320.8,412.4 Z" 
                  fill="#f8696b" stroke="none" class="section-path" id="interoceptive-section" 
                  data-section="interoceptive" onclick="showSectionInfo('interoceptive')"/>
            
            <!-- Tactile - Red (poorly regulated) - Centered at 225° -->
            <path d="M155.5,471.2 A245,245 0 0,1 28.8,344.5 L87.6,320.8 A180,180 0 0,0 179.2,412.4 Z" 
                  fill="#f8696b" stroke="none" class="section-path" id="tactile-section" 
                  data-section="tactile" onclick="showSectionInfo('tactile')"/>
            
            <!-- Smell - Yellow (moderately regulated) - Centered at 270° -->
            <path d="M28.8,344.5 A245,245 0 0,1 28.8,155.5 L87.6,179.2 A180,180 0 0,0 87.6,320.8 Z" 
                  fill="#ffe699" stroke="none" class="section-path" id="smell-section" 
                  data-section="smell" onclick="showSectionInfo('smell')"/>
            
            <!-- Taste - Yellow (moderately regulated) - Centered at 315° -->
            <path d="M28.8,155.5 A245,245 0 0,1 155.5,28.8 L179.2,83.6 A180,180 0 0,0 87.6,179.2 Z" 
                  fill="#ffe699" stroke="none" class="section-path" id="taste-section" 
                  data-section="taste" onclick="showSectionInfo('taste')"/>
            
            <!-- Middle white ring with border -->
            <circle cx="250" cy="250" r="179.5" fill="white" stroke="black" stroke-width="1"/>
            
            <!-- The adaptation score hub in the center - with enhanced stability coin model -->
            <!-- Main hub circle - its color represents position on spectrum -->
            <circle cx="250" cy="250" r="70" fill="#4caf50" stroke="none" 
                   id="hub-circle" class="wheel-hub" onclick="showHubInfo()"/>
            
            <!-- Hub border - thickness represents stability (inversely related to variability) -->
            <circle cx="250" cy="250" r="75" fill="none" stroke="#333" stroke-width="10" stroke-opacity="0.7"
                   id="hub-border" onclick="showHubInfo()"/>
            
            <!-- Position value (-10 to +10) -->
            <text x="250" y="240" text-anchor="middle" font-size="28" font-weight="bold" fill="white" pointer-events="none" id="hub-position">+2</text>
            
            <!-- Variability value - representing coin thickness -->
            <text x="250" y="270" text-anchor="middle" font-size="28" font-weight="bold" fill="white" pointer-events="none" id="hub-variability">±5</text>
            
            <!-- Spokes connecting hub to sections - with enhanced clickable areas -->
            <!-- FIXED: Starting points moved to edge of hub circle (not penetrating) -->
            
            <!-- Visual (Green): Solid line with wider clickable area -->
            <g class="spoke-group" id="visual-spoke-group">
              <!-- Invisible wider line for better click area -->
              <line x1="250" y1="180" x2="250" y2="70" class="spoke-clickable-area" stroke="transparent"
              onclick="showSpokeInfo('visual')"/>
              <!-- Visible line - stopping at hub edge -->
              <line x1="250" y1="180" x2="250" y2="70" stroke="black" stroke-width="2" class="spoke"
                  id="visual-spoke" data-section="visual"/>
            </g>
            
            <!-- Auditory (Yellow): Dashed line with wider clickable area -->
            <g class="spoke-group" id="auditory-spoke-group">
              <!-- Invisible wider line for better click area -->
              <line x1="302" y1="198" x2="377" y2="123" class="spoke-clickable-area" stroke="transparent" 
                  onclick="showSpokeInfo('auditory')"/>
              <!-- Visible line - stopping at hub edge -->
              <line x1="302" y1="198" x2="377" y2="123" stroke="black" stroke-width="2" stroke-dasharray="5,3" 
                  class="spoke" id="auditory-spoke" data-section="auditory"/>
            </g>
            
            <!-- Vestibular (Green): Solid line with wider clickable area -->
            <g class="spoke-group" id="vestibular-spoke-group">
              <!-- Invisible wider line for better click area -->
              <line x1="320" y1="250" x2="430" y2="250" class="spoke-clickable-area" stroke="transparent" 
                  onclick="showSpokeInfo('vestibular')"/>
              <!-- Visible line - stopping at hub edge -->
              <line x1="320" y1="250" x2="430" y2="250" stroke="black" stroke-width="2" class="spoke"
                  id="vestibular-spoke" data-section="vestibular"/>
            </g>
            
            <!-- Proprioceptive (Yellow): Dashed line with wider clickable area -->
            <g class="spoke-group" id="proprioceptive-spoke-group">
              <!-- Invisible wider line for better click area -->
              <line x1="302" y1="302" x2="377" y2="377" class="spoke-clickable-area" stroke="transparent" 
                  onclick="showSpokeInfo('proprioceptive')"/>
              <!-- Visible line - stopping at hub edge -->
              <line x1="302" y1="302" x2="377" y2="377" stroke="black" stroke-width="2" stroke-dasharray="5,3" 
                  class="spoke" id="proprioceptive-spoke" data-section="proprioceptive"/>
            </g>
            
            <!-- Interoceptive (Red): Dashed line with wider clickable area -->
            <g class="spoke-group" id="interoceptive-spoke-group">
              <!-- Invisible wider line for better click area -->
              <line x1="250" y1="320" x2="250" y2="430" class="spoke-clickable-area" stroke="transparent" 
                  onclick="showSpokeInfo('interoceptive')"/>
              <!-- Visible line - stopping at hub edge -->
              <line x1="250" y1="320" x2="250" y2="430" stroke="black" stroke-width="2" stroke-dasharray="5,3" 
                  class="spoke" id="interoceptive-spoke" data-section="interoceptive"/>
            </g>
            
            <!-- Tactile (Red): Dashed line with wider clickable area -->
            <g class="spoke-group" id="tactile-spoke-group">
              <!-- Invisible wider line for better click area -->
              <line x1="198" y1="302" x2="123" y2="377" class="spoke-clickable-area" stroke="transparent" 
                  onclick="showSpokeInfo('tactile')"/>
              <!-- Visible line - stopping at hub edge -->
              <line x1="198" y1="302" x2="123" y2="377" stroke="black" stroke-width="2" stroke-dasharray="5,3" 
                  class="spoke" id="tactile-spoke" data-section="tactile"/>
            </g>
            
            <!-- Smell (Yellow): Dashed line with wider clickable area -->
            <g class="spoke-group" id="smell-spoke-group">
              <!-- Invisible wider line for better click area -->
              <line x1="180" y1="250" x2="70" y2="250" class="spoke-clickable-area" stroke="transparent" 
                  onclick="showSpokeInfo('smell')"/>
              <!-- Visible line - stopping at hub edge -->
              <line x1="180" y1="250" x2="70" y2="250" stroke="black" stroke-width="2" stroke-dasharray="5,3" 
                  class="spoke" id="smell-spoke" data-section="smell"/>
            </g>
            
            <!-- Taste (Yellow): Dashed line with wider clickable area -->
            <g class="spoke-group" id="taste-spoke-group">
              <!-- Invisible wider line for better click area -->
              <line x1="198" y1="198" x2="123" y2="123" class="spoke-clickable-area" stroke="transparent" 
                  onclick="showSpokeInfo('taste')"/>
              <!-- Visible line - stopping at hub edge -->
              <line x1="198" y1="198" x2="123" y2="123" stroke="black" stroke-width="2" stroke-dasharray="5,3" 
                  class="spoke" id="taste-spoke" data-section="taste"/>
            </g>
            
            <!-- Warning lines for severe dysregulation - properly breaking through sections -->
            <!-- White background lines at section boundaries -->
            <!-- NE quadrant (Visual/Auditory boundary) -->
            <line x1="377" y1="123" x2="423" y2="77" stroke="white" stroke-width="4" class="breakthrough-background" data-sections="visual,auditory"/>
            
            <!-- SE quadrant (Vestibular/Proprioceptive boundary) -->
            <line x1="377" y1="377" x2="423" y2="423" stroke="white" stroke-width="4" class="breakthrough-background" data-sections="vestibular,proprioceptive"/>
            
            <!-- SW quadrant (Interoceptive/Tactile boundary) -->
            <line x1="123" y1="377" x2="77" y2="423" stroke="white" stroke-width="4" class="breakthrough-background" data-sections="interoceptive,tactile"/>
            
            <!-- NW quadrant (Smell/Taste boundary) -->
            <line x1="123" y1="123" x2="77" y2="77" stroke="white" stroke-width="4" class="breakthrough-background" data-sections="smell,taste"/>
            
            <!-- White background for smell section spoke (between outside edge and white ring) -->
            <line x1="9" y1="250" x2="87.6" y2="250" stroke="white" stroke-width="4" class="breakthrough-background" data-sections="smell"/>
            
            <!-- White background for interoceptive section spoke (between outside edge and white ring) -->
            <line x1="250" y1="491" x2="250" y2="412.4" stroke="white" stroke-width="4" class="breakthrough-background" data-sections="interoceptive"/>
            
            <!-- Red dashed lines at section boundaries -->
            <!-- NE quadrant (Visual/Auditory boundary) -->
            <line x1="377" y1="123" x2="423" y2="77" stroke="red" stroke-width="2" stroke-dasharray="5,3" class="breakthrough-line" data-sections="visual,auditory" style="opacity: 0;"/>
            
            <!-- SE quadrant (Vestibular/Proprioceptive boundary) -->
            <line x1="377" y1="377" x2="423" y2="423" stroke="red" stroke-width="2" stroke-dasharray="5,3" class="breakthrough-line" data-sections="vestibular,proprioceptive" style="opacity: 0;"/>
            
            <!-- SW quadrant (Interoceptive/Tactile boundary) -->
            <line x1="123" y1="377" x2="77" y2="423" stroke="red" stroke-width="2" stroke-dasharray="5,3" class="breakthrough-line" data-sections="interoceptive,tactile" style="opacity: 0;"/>
            
            <!-- NW quadrant (Smell/Taste boundary) -->
            <line x1="123" y1="123" x2="77" y2="77" stroke="red" stroke-width="2" stroke-dasharray="5,3" class="breakthrough-line" data-sections="smell,taste" style="opacity: 0;"/>
            
            <!-- Red dashed line for smell section spoke (between outside edge and white ring) -->
            <line x1="9" y1="250" x2="87.6" y2="250" stroke="red" stroke-width="2" stroke-dasharray="5,3" class="breakthrough-line" data-sections="smell" style="opacity: 0;"/>
            
            <!-- Red dashed line for interoceptive section spoke (between outside edge and white ring) -->
            <line x1="250" y1="491" x2="250" y2="412.4" stroke="red" stroke-width="2" stroke-dasharray="5,3" class="breakthrough-line" data-sections="interoceptive" style="opacity: 0;"/>
            
            <!-- Section Labels - Positioned in the middle of each section -->
            <text x="250" y="40" text-anchor="middle" font-size="14" font-weight="bold" fill="black" pointer-events="none">Visual</text>
            <text x="400" y="100" text-anchor="middle" font-size="14" font-weight="bold" fill="black" transform="rotate(45,400,100)" pointer-events="none">Auditory</text>
            <text x="460" y="250" text-anchor="middle" font-size="14" font-weight="bold" fill="black" transform="rotate(-90,460,250)" pointer-events="none">Vestibular</text>
            <text x="400" y="400" text-anchor="middle" font-size="14" font-weight="bold" fill="black" transform="rotate(-45,400,400)" pointer-events="none">Proprioceptive</text>
            <text x="250" y="460" text-anchor="middle" font-size="14" font-weight="bold" fill="black" pointer-events="none">Interoceptive</text>
            <text x="100" y="400" text-anchor="middle" font-size="14" font-weight="bold" fill="black" transform="rotate(45,100,400)" pointer-events="none">Tactile</text>
            <text x="40" y="250" text-anchor="middle" font-size="14" font-weight="bold" fill="black" transform="rotate(270,40,250)" pointer-events="none">Smell</text>
            <text x="100" y="100" text-anchor="middle" font-size="14" font-weight="bold" fill="black" transform="rotate(-45,100,100)" pointer-events="none">Taste</text>
          </svg>
        </div>
      </div>
      
      <!-- Research References Button -->
      <button class="research-references-btn" id="research-references-btn">Research References ▼</button>
      
      <!-- Research References Panel -->
      <div class="research-panel" id="research-panel">
        <h4>Research Basis for Adaptation Thermostat</h4>
        <p><strong>1. Sensory Processing Integration</strong><br>
           Schaaf, R. C., & Case-Smith, J. (2014). Sensory interventions for children with autism. Journal of Comparative Neurology, 522(18), 4082-4092.</p>
        
        <p><strong>2. Polyvagal Theory & Nervous System Regulation</strong><br>
           Porges, S. W. (2018). Polyvagal theory: A framework for understanding the effectiveness of sensory modulation. In A. A. Shaikh & V. G. Zayas (Eds.), Advances in sensory processing research (pp. 189-204).</p>
        
        <p><strong>3. Interoception & Self-Regulation</strong><br>
           Craig, A. D. (2015). How do you feel?: An interoceptive moment with your neurobiological self. Princeton University Press.</p>
        
        <p><strong>4. Sensory-Based Interventions</strong><br>
           Miller, L. J., Anzalone, M. E., Lane, S. J., Cermak, S. A., & Osten, E. T. (2017). Concept evolution in sensory integration: A proposed nosology for diagnosis. American Journal of Occupational Therapy, 61(2), 135-140.</p>
        
        <p><strong>5. Shutdown Prevention</strong><br>
           Kozlowska, K., Walker, P., McLean, L., & Carrive, P. (2019). Fear and the defense cascade: Clinical implications and management. Harvard Review of Psychiatry, 23(4), 263-287.</p>
        
        <p><strong>6. Adaptive Capacity Measurement</strong><br>
           Reynolds, S., Lane, S. J., & Gennings, C. (2017). The moderating role of sensory overresponsivity in HPA activity. Journal of Attention Disorders, 21(2), 167-177.</p>
        
        <p><strong>7. Breakthrough Indicators</strong><br>
           Mahler, K. (2019). Interoception: The hidden sense that shapes wellbeing. The British Journal of Occupational Therapy, 82(5), 269-271.</p>
        
        <p><strong>8. Institutional Adaptive Research</strong><br>
           Taylor, A., & Shallish, L. (2019). The logic of bio-meritocracy in the promotion of higher education accessibility. Disability & Society, 34(7-8), 1200-1223.</p>
      </div>
    </div>
    
    <!-- Placeholder for other tabs (from original Adaptherm) -->
    <div id="individual" class="tab-content">
      <h2>Individual Adaptation Level</h2>
      <p>This content would be imported from the original Adaptherm application.</p>
    </div>
    
    <div id="institutional" class="tab-content">
      <h2>Institutional Adaptation Level</h2>
      <p>This content would be imported from the original Adaptherm application.</p>
    </div>
    
    <div id="uk-case" class="tab-content">
      <h2>UK Case Study</h2>
      <p>This content would be imported from the original Adaptherm application.</p>
    </div>
    
    <!-- Overlay for info panels -->
    <div class="panel-overlay" id="panel-overlay"></div>
    
    <!-- Hub Information Panel - Improved with simplified language -->
    <div class="info-panel" id="hub-panel">
      <div class="info-panel-header">
        <h2 class="info-panel-title">Stability Coin Model</h2>
        <div class="info-panel-controls">
          <button class="expand-panel" onclick="togglePanelSize('hub-panel')" title="Expand/Collapse Panel">⤢</button>
          <button class="close-panel" onclick="closePanel('hub-panel')" title="Close Panel">&times;</button>
        </div>
      </div>
      
      <!-- Streamlined stability inputs -->
      <div class="stability-inputs">
        <div class="stability-slider-section">
          <h3>Where You Are Now <span class="position-value" id="position-slider-value">+2</span></h3>
          
          <!-- Position value displayed prominently above gauge - ENHANCED -->
          <div class="position-value-container">
          </div>
          
          <!-- Visual position gauge with no extra sliders -->
          <div class="position-gauge">
            <div class="position-marker" id="position-marker" style="left: 62%;"></div>
          </div>
          
          <!-- Labels below gauge -->
          <div class="position-labels">
            <span>Shutdown</span>
            <span>Balanced</span>
            <span>Meltdown</span>
          </div>
          
          <!-- Completely hidden input just for internal tracking -->
          <input type="range" min="-10" max="10" value="2" class="slider-input" id="position-slider" style="display: none;">
        
        
          <h3>How Much You Change <span class="slider-value" id="variability-slider-value">±5</span></h3>
        <div class="slider-row">
          <input type="range" min="0" max="10" value="5" class="slider-input" id="variability-slider">
        </div>
        
        <!-- FIXED: Modified to use new variability-spectrum-info class -->
        <div class="variability-spectrum-info">
          <span>Stable (Better)</span>
          <span>Frequent flips</span>
        </div>
        
        <div class="event-input-section">
          <h3>Event Tracking</h3>
          <div class="event-input-row">
            <label for="event-count">Incidents (last 30 days):</label>
            <input type="number" id="event-count" min="0" max="30" value="3" class="event-input">
            <button class="calculate-btn" id="calculate-from-events">Calculate</button>
          </div>
        </div>
        
        <button class="apply-changes" id="apply-hub-changes">Apply Changes</button>
        </div>
      </div>
      
      <!-- Trend summary cards - MOVED INTO HUB PANEL -->
      <div class="trend-info">
        <div class="trend-card">
          <div class="trend-value">3.2</div>
          <div class="trend-label">Previous Average</div>
          <div class="trend-direction trend-up">
            <span>▲</span> Getting Better
          </div>
        </div>
        
        <div class="trend-card">
          <div class="trend-value">7</div>
          <div class="trend-label">Recent Events</div>
          <div class="trend-direction trend-down">
            <span>▼</span> Fewer Than Before
          </div>
        </div>
        
        <div class="trend-card">
          <div class="trend-value">45m</div>
          <div class="trend-label">Recovery Time</div>
          <div class="trend-direction trend-down">
            <span>▼</span> Faster Recovery
          </div>
        </div>
      </div>
      
      <!-- Chart container for trends - MOVED INTO HUB PANEL -->
      <div class="chart-container" id="hub-chart-container">
        <canvas id="hubTrendChart"></canvas>
      </div>
      
      <!-- Recommendations section -->
      <h3>What Helps Most</h3>
      <div id="individualRecommendations" class="recommendations">
        <p><strong>Based on your current state (+2 with ±5 changes):</strong></p>
        <ul>
          <li>Notice when you start feeling overstimulated - look for early warning signs</li>
          <li>Create a regular daily schedule with predictable sensory activities</li>
          <li>Reduce environmental triggers when possible (dim lights, lower noise)</li>
          <li>Practice grounding techniques when you notice changes starting</li>
        </ul>
      </div>
    </div>
    
    <!-- Section Information Panel - Expandable -->
    <div class="info-panel" id="section-panel">
      <div class="info-panel-header">
        <h2 class="info-panel-title" id="section-panel-title">Sensory System</h2>
        <div class="info-panel-controls">
          <button class="expand-panel" onclick="togglePanelSize('section-panel')" title="Expand/Collapse Panel">⤢</button>
          <button class="close-panel" onclick="closePanel('section-panel')" title="Close Panel">&times;</button>
        </div>
      </div>
      
      <div class="trend-info">
        <div class="trend-card">
          <div class="trend-value" id="section-score">0.0</div>
          <div class="trend-label">Current Score</div>
          <div class="trend-direction" id="section-trend"></div>
        </div>
        
        <div class="trend-card">
          <div class="trend-value" id="section-events">0</div>
          <div class="trend-label">Related Shutdown Events</div>
          <div class="trend-direction" id="section-events-trend"></div>
        </div>
      </div>
      
      <div class="chart-container" id="section-chart-container">
        <canvas id="sectionTrendChart"></canvas>
      </div>
      
      <h3>Current Challenges</h3>
      <ul id="section-challenges">
        <!-- Populated dynamically based on selected section -->
      </ul>
      
      <!-- Added section performance slider -->
      <div class="slider-container">
        <h3 class="slider-title" id="section-slider-title">Adjust Section Performance</h3>
        <p>Use this slider to see how changes in this sensory system's performance would affect the wheel visualization.</p>
        
        <div class="slider-row">
          <div class="slider-label" id="section-slider-label">Performance Score:</div>
          <input type="range" min="1" max="10" step="0.1" value="5.0" class="slider-input" id="section-slider">
          <div class="slider-value" id="section-slider-value">5.0</div>
        </div>
        
        <button class="apply-changes" id="apply-section-changes">Apply Changes</button>
      </div>
    </div>
    
    <!-- Spoke Information Panel - Expandable -->
    <div class="info-panel" id="spoke-panel">
      <div class="info-panel-header">
        <h2 class="info-panel-title" id="spoke-panel-title">Recommendations</h2>
        <div class="info-panel-controls">
          <button class="expand-panel" onclick="togglePanelSize('spoke-panel')" title="Expand/Collapse Panel">⤢</button>
          <button class="close-panel" onclick="closePanel('spoke-panel')" title="Close Panel">&times;</button>
        </div>
      </div>
      
      <div class="recommendations-list" id="spoke-recommendations">
        <!-- Populated dynamically based on selected spoke -->
      </div>
      
      <div class="contact-options">
        <h3 class="contact-title">Co-Create Solutions With:</h3>
        <div class="contact-list" id="contact-list">
          <!-- Populated dynamically based on selected spoke -->
        </div>
      </div>
    </div>
  </div>

  <script>
    // Data for each sensory section
    const sectionPerformanceData = {
      visual: { score: 8.2, previousScore: 7.8, events: 1, previousEvents: 3, color: "#a8d08d" },
      auditory: { score: 6.5, previousScore: 5.2, events: 2, previousEvents: 4, color: "#ffe699" },
      vestibular: { score: 7.8, previousScore: 7.5, events: 1, previousEvents: 2, color: "#a8d08d" },
      proprioceptive: { score: 6.2, previousScore: 5.5, events: 2, previousEvents: 3, color: "#ffe699" },
      interoceptive: { score: 2.4, previousScore: 1.8, events: 5, previousEvents: 8, color: "#f8696b" },
      tactile: { score: 3.6, previousScore: 2.9, events: 4, previousEvents: 6, color: "#f8696b" },
      smell: { score: 5.8, previousScore: 5.2, events: 1, previousEvents: 3, color: "#ffe699" },
      taste: { score: 5.9, previousScore: 5.5, events: 1, previousEvents: 2, color: "#ffe699" }
    };
    
    // Individual adaptation data
    let individualData = [
      { month: 'Jan', shutdownFrequency: 8, recoveryTime: 4, adaptiveCapacity: 3, overallScore: 3.0 },
      { month: 'Feb', shutdownFrequency: 7, recoveryTime: 5, adaptiveCapacity: 3, overallScore: 3.7 },
      { month: 'Mar', shutdownFrequency: 6, recoveryTime: 6, adaptiveCapacity: 4, overallScore: 4.7 }
    ];
    
    // Custom metrics tracking
    let individualCustomMetrics = [];
    
    // Individual chart reference
    let individualChart = null;
    
    // Challenges for each sensory section
    const sectionChallenges = {
      visual: [
        "Fluorescent lighting causes eye strain and headaches",
        "Difficulty with visual tracking in busy environments",
        "Screen glare triggers discomfort"
      ],
      auditory: [
        "Background conversations make focus difficult",
        "Sudden loud noises cause startle response",
        "Multiple sound sources create overload"
      ],
      vestibular: [
        "Difficulty with moving crowds",
        "Car travel causes motion sensitivity",
        "Quick position changes cause dizziness"
      ],
      proprioceptive: [
        "Difficulty gauging physical space in crowded areas",
        "Bumping into objects frequently",
        "Trouble with fine motor control when stressed"
      ],
      interoceptive: [
        "Difficulty recognizing hunger cues until extreme",
        "Poor awareness of emotional states before meltdown",
        "Unable to identify source of physical discomfort",
        "Temperature regulation issues",
        "Delayed recognition of need for bathroom"
      ],
      tactile: [
        "Clothing tags and seams cause significant discomfort",
        "Light touch feels painful or overwhelming",
        "Certain fabric textures are intolerable",
        "Difficulty with personal care due to touch sensitivity"
      ],
      smell: [
        "Strong perfumes trigger nausea",
        "Food smells can be overwhelming",
        "Cleaning product odors cause headaches"
      ],
      taste: [
        "Limited food tolerance due to texture issues",
        "Flavor sensitivities restrict diet",
        "Food aversions increase during stress"
      ]
    };
    
    // Recommendations for each sensory system
    const spokeRecommendations = {
      visual: [
        { title: "Lighting Modifications", desc: "Use warm, dimmable lighting instead of fluorescent. Consider light filtering glasses for unavoidable bright environments." },
        { title: "Visual Organization", desc: "Reduce visual clutter in your environment. Use solid colors rather than patterns where possible." },
        { title: "Screen Adjustments", desc: "Use night mode or blue light filters on devices. Adjust contrast and brightness for comfort." }
      ],
      auditory: [
        { title: "Noise Management", desc: "Use noise-canceling headphones in loud environments. Consider white noise machines to mask disruptive sounds." },
        { title: "Communication Preferences", desc: "Request one person speak at a time. Ask for written instructions when verbal becomes overwhelming." },
        { title: "Sound Breaks", desc: "Schedule regular quiet periods throughout your day for auditory recovery." }
      ],
      vestibular: [
        { title: "Movement Strategies", desc: "Use wall or railing support when available. Practice grounding techniques when feeling disoriented." },
        { title: "Travel Adaptations", desc: "Choose window seats during travel. Use visual fixation points to reduce motion sensitivity." },
        { title: "Postural Support", desc: "Consider supportive seating that promotes stability. Use weighted items for enhanced body awareness." }
      ],
      proprioceptive: [
        { title: "Heavy Work Activities", desc: "Incorporate pushing, pulling, or carrying activities into your routine for regulation." },
        { title: "Weighted Tools", desc: "Use weighted blankets, vests, or lap pads for increased body awareness." },
        { title: "Movement Breaks", desc: "Schedule regular movement activities that involve resistance for proprioceptive input." }
      ],
      interoceptive: [
        { title: "Body Awareness Practice", desc: "Set regular reminders for basic needs (eating, drinking, restroom). Practice body scanning techniques daily." },
        { title: "Emotion Tracking", desc: "Use emotion charts or apps to check in with yourself regularly throughout the day." },
        { title: "Scheduled Breaks", desc: "Implement preventative breaks before reaching overload, regardless of perceived need." },
        { title: "Temperature Regulation", desc: "Layer clothing for quick adjustment. Carry portable cooling/heating options." }
      ],
      tactile: [
        { title: "Clothing Adaptations", desc: "Choose seamless clothing, remove tags, and opt for preferred textures and looser fits." },
        { title: "Touch Boundaries", desc: "Communicate clear boundaries about physical contact. Consider physical buffer spaces in public." },
        { title: "Desensitization Techniques", desc: "Work with an OT on gradually increasing tolerance to different textures." },
        { title: "Protective Strategies", desc: "Use gloves for unavoidable tactile challenges. Create physical barriers in shared spaces." }
      ],
      smell: [
        { title: "Scent Management", desc: "Request fragrance-free products in your environment. Use personal air filters in unavoidable situations." },
        { title: "Masking Techniques", desc: "Carry preferred scents (essential oils) to counteract overwhelming smells." },
        { title: "Environmental Controls", desc: "Improve ventilation in spaces with strong odors. Communicate about scheduled cleaning or maintenance." }
      ],
      taste: [
        { title: "Food Preparation", desc: "Separate food items on plate. Prepare foods consistently in predictable ways." },
        { title: "Texture Management", desc: "Identify safe foods across various texture categories. Gradually explore similar textures." },
        { title: "Stress Reduction", desc: "Reduce additional sensory input during meals. Create calm, predictable eating environments." }
      ]
    };
    
    // Trusted contacts and professionals for each sensory system
    const sectionContacts = {
      visual: {
        trusted: ["Sarah (Partner)", "Michael (Roommate)"],
        professional: ["Dr. Martinez (Optometrist)", "Robin (Occupational Therapist)"]
      },
      auditory: {
        trusted: ["James (Brother)", "Taylor (Coworker)"],
        professional: ["Dr. Chen (Audiologist)", "Sam (Speech Therapist)"]
      },
      vestibular: {
        trusted: ["Chris (Partner)", "Alex (Friend)"],
        professional: ["Dr. Singh (Neurologist)", "Jordan (Physical Therapist)"]
      },
      proprioceptive: {
        trusted: ["Morgan (Partner)", "Jamie (Friend)"],
        professional: ["Casey (Occupational Therapist)", "Dr. Lee (Physiotherapist)"]
      },
      interoceptive: {
        trusted: ["Riley (Partner)", "Drew (Sibling)"],
        professional: ["Dr. Williams (Psychiatrist)", "Taylor (Therapist)"]
      },
      tactile: {
        trusted: ["Jordan (Roommate)", "Sam (Partner)"],
        professional: ["Dr. Johnson (Sensory Specialist)", "Alex (Occupational Therapist)"]
      },
      smell: {
        trusted: ["Casey (Partner)", "Morgan (Friend)"],
        professional: ["Dr. Rodriguez (ENT Specialist)", "Taylor (Environmental Consultant)"]
      },
      taste: {
        trusted: ["Jamie (Partner)", "Robin (Friend)"],
        professional: ["Dr. Kim (Dietitian)", "Casey (Feeding Specialist)"]
      }
    };
    
    // Simplified emergency interventions with everyday language
    const simplifiedEmergencyInterventions = {
      visual: {
        immediate: [
          "Turn down lights or close blinds",
          "Put on sunglasses even indoors",
          "Close your eyes for a minute",
          "Move to a less bright area"
        ],
        shortTerm: [
          "Find a simple, calm space with less to look at",
          "Use an eye mask for 15-30 minutes",
          "Take a break from screens",
          "Use a cold cloth on your forehead"
        ]
      },
      auditory: {
        immediate: [
          "Put on headphones or earplugs",
          "Move away from noise",
          "Play white noise to block out sounds",
          "Cover your ears if needed"
        ],
        shortTerm: [
          "Find a quiet place to rest",
          "Listen to familiar music you like",
          "Use a sound machine for background noise",
          "Try not to talk much while recovering"
        ]
      },
      vestibular: {
        immediate: [
          "Sit down with your back against a wall",
          "Look at something that isn't moving",
          "Keep your head still and breathe slowly",
          "Press gently on the sides of your head"
        ],
        shortTerm: [
          "Stay still for about 30 minutes",
          "Use a weighted blanket on your shoulders",
          "Stay in a stable position",
          "Try slow, gentle rocking if it helps"
        ]
      },
      proprioceptive: {
        immediate: [
          "Press firmly on your arms and legs",
          "Push against a wall with your hands",
          "Push up from your chair with your arms",
          "Put something heavy on your lap"
        ],
        shortTerm: [
          "Wrap yourself in a heavy blanket",
          "Do pushing or pulling activities",
          "Do wall push-ups or chair squats",
          "Wear tight-fitting clothes"
        ]
      },
      interoceptive: {
        immediate: [
          "Check in with your body - hungry? thirsty? hot? cold?",
          "Take 5 deep belly breaths",
          "Rate how you feel from 1-10",
          "Place your hand on your chest or stomach"
        ],
        shortTerm: [
          "Eat a small snack even if not hungry",
          "Drink some water",
          "Add or remove clothing to get comfortable",
          "Use the bathroom even if you don't feel urgent need",
          "Plan for 30 minutes of quiet time"
        ]
      },
      tactile: {
        immediate: [
          "Remove uncomfortable clothing",
          "Apply firm pressure instead of light touch",
          "Create space between yourself and others",
          "Touch something with a texture you like"
        ],
        shortTerm: [
          "Change into your most comfortable clothes",
          "Take a shower at your preferred temperature",
          "Use a weighted blanket",
          "Avoid unexpected touching for a few hours"
        ]
      },
      smell: {
        immediate: [
          "Move away from the smell quickly",
          "Breathe through your mouth instead of nose",
          "Smell something you like (mint, lemon)",
          "Go outside for fresh air"
        ],
        shortTerm: [
          "Open windows to clear the air",
          "Use an air purifier if you have one",
          "Keep your favorite scent nearby",
          "Change clothes if they absorbed the smell"
        ]
      },
      taste: {
        immediate: [
          "Remove food from your mouth if needed",
          "Rinse with water or brush teeth",
          "Try a mint or gum",
          "Focus on a texture or taste you like"
        ],
        shortTerm: [
          "Stick to foods you know are safe",
          "Avoid trying new foods until you feel better",
          "Keep foods separate on your plate",
          "Prepare food in ways you know you like"
        ]
      }
    };
    
    // Hub trend data (for demo)
    const hubTrendData = {
      labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
      datasets: [
        {
          label: 'Position',
          data: [-2, -1, 0, 1, 1.5, 2],
          borderColor: '#2196f3',
          backgroundColor: 'rgba(33, 150, 243, 0.1)',
          borderWidth: 3,
          tension: 0.2
        },
        {
          label: 'Variability',
          data: [8, 7, 6, 6, 5, 5],
          borderColor: '#ff9800',
          backgroundColor: 'rgba(255, 152, 0, 0.1)',
          borderWidth: 2,
          tension: 0.2
        },
        {
          label: 'Shutdowns',
          data: [12, 11, 9, 8, 7, 7],
          borderColor: '#f44336',
          backgroundColor: 'rgba(244, 67, 54, 0.1)',
          borderWidth: 2,
          tension: 0.2,
          yAxisID: 'y1'
        }
      ]
    };
    
    // Section trend data (template to be populated based on selection)
    const sectionTrendDataTemplate = {
      labels: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun'],
      datasets: [
        {
          label: 'Section Score',
          borderWidth: 3,
          tension: 0.2
        },
        {
          label: 'Related Shutdowns',
          borderColor: '#f44336',
          backgroundColor: 'rgba(244, 67, 54, 0.1)',
          borderWidth: 2,
          tension: 0.2
        }
      ]
    };
    
    // Global variable to track current section
    let currentSection = '';
    
    // Calculate overall adaptation score based on all section scores
    function calculateAdaptationScore() {
      const scores = Object.values(sectionPerformanceData).map(data => data.score);
      const sum = scores.reduce((total, score) => total + score, 0);
      return (sum / scores.length).toFixed(1);
    }
    
    // Enhanced function to update hub visualization based on position and variability
    function updateHubVisualization(position, variability) {
      // Update text values
      const positionElem = document.getElementById('hub-position');
      const variabilityElem = document.getElementById('hub-variability');
      const hubCircle = document.getElementById('hub-circle');
      const hubBorder = document.getElementById('hub-border');
      
      if (positionElem) positionElem.textContent = position >= 0 ? `+${position}` : position;
      if (variabilityElem) variabilityElem.textContent = `±${variability}`;
      
      // Calculate color based on position (0 is green, extremes are red/blue)
      let hubColor;
      const absPosition = Math.abs(position);
      
      if (absPosition < 2) {
        hubColor = "#4caf50"; // Green for balanced
      } else if (absPosition < 4) {
        hubColor = position > 0 ? "#8bc34a" : "#2196f3"; // Light green/blue for slight imbalance
      } else if (absPosition < 6) {
        hubColor = position > 0 ? "#ffc107" : "#03a9f4"; // Yellow/blue for moderate imbalance
      } else if (absPosition < 8) {
        hubColor = position > 0 ? "#ff9800" : "#673ab7"; // Orange/purple for significant imbalance
      } else {
        hubColor = position > 0 ? "#f44336" : "#3f51b5"; // Red/indigo for extreme imbalance
      }
      
      // Update hub color
      if (hubCircle) hubCircle.setAttribute("fill", hubColor);
      
      // Update hub border thickness based on variability (stability)
      // Higher variability (less stability) = thinner border
      if (hubBorder) {
        // Calculate border width: 15 - variability (so high variability = thin border)
        const borderWidth = Math.max(2, 15 - variability);
        hubBorder.setAttribute("stroke-width", borderWidth);
        
        // Also subtly adjust hub size based on stability (more stable = slightly larger)
        const hubSize = 70 - (variability / 2); // Base size is 70, reduce slightly with higher variability
        hubCircle.setAttribute("r", hubSize);
        hubBorder.setAttribute("r", hubSize + 5); // Border is slightly larger than hub
      }
      
      // Update recommendations based on position and variability
      updateRecommendations(position, variability);
      
      // Update marker position on the gauge
      const posMarker = document.getElementById('position-marker');
      if (posMarker) {
        const markerPos = 50 + (position * 5);
        posMarker.style.left = `${markerPos}%`;
      }
      
      // Update the position-slider-value display
      const posValueDisplay = document.getElementById('position-slider-value');
      if (posValueDisplay) {
        posValueDisplay.textContent = position >= 0 ? `+${position}` : position;
      }
    }
    
    // Function to generate position-based recommendations
    function updateRecommendations(position, variability) {
      const recommendationsDiv = document.getElementById('individualRecommendations');
      if (!recommendationsDiv) return;
      
      let recommendations = [];
      const absPosition = Math.abs(position);
      
      // State-specific recommendations
      if (position < -3) {
        // Shutdown state recommendations
        recommendations.push(
          "Add more sensory input to help your system activate",
          "Use upbeat music or bright lights if they help engage you",
          "Try movement activities like stretching or walking",
          "Focus on one task at a time to help build momentum"
        );
      } else if (position > 3) {
        // Meltdown state recommendations
        recommendations.push(
          "Create a calmer sensory environment by reducing input",
          "Find a quiet space with less noise and less visual stimulation",
          "Use deep pressure like a weighted blanket if it helps",
          "Try slow breathing techniques to help regulate"
        );
      } else {
        // Balanced state recommendations
        recommendations.push(
          "Notice what helps you stay in this balanced state",
          "Create a regular daily schedule with predictable activities",
          "Keep a record of what environments work best for you",
          "Practice body awareness to notice early signs of change"
        );
      }
      
      // Add stability-based recommendations
      if (variability > 5) {
        recommendations.push(
          "Work on creating more predictable patterns in your day",
          "Notice early signs of state changes and respond quickly",
          "Develop a consistent sensory diet throughout your day",
          "Practice transitions between different environments"
        );
      }
      
      // Update the recommendations display
      recommendationsDiv.innerHTML = `
        <p><strong>Based on your current state (${position >= 0 ? '+' : ''}${position} with ±${variability} changes):</strong></p>
        <ul>
          ${recommendations.map(rec => `<li>${rec}</li>`).join('')}
        </ul>
      `;
    }
    
    // Function to draw the sensory wheel
    function drawSensoryWheel() {
      // Update each section color based on individual section score
      Object.keys(sectionPerformanceData).forEach(section => {
        const score = sectionPerformanceData[section].score;
        let color;
        
        if (score >= 8) {
          color = "#a8d08d"; // Green for well-regulated (scores 8-10)
        } else if (score >= 4) {
          color = "#ffe699"; // Yellow for moderately regulated (scores 4-7.9)
        } else {
          color = "#f8696b"; // Red for poorly regulated (scores 1-3.9)
        }
        
        // Update section color
        const sectionElement = document.getElementById(`${section}-section`);
        if (sectionElement) {
          sectionElement.setAttribute("fill", color);
          sectionPerformanceData[section].color = color;
        }
        
        // Update spoke style (solid for well-regulated, dashed for others)
        const spokeElement = document.getElementById(`${section}-spoke`);
        if (spokeElement) {
          if (score >= 8) {
            spokeElement.removeAttribute("stroke-dasharray");
          } else {
            spokeElement.setAttribute("stroke-dasharray", "5,3");
          }
        }
      });
      
      // Update breakthrough line visibility based on section scores
      const breakthroughLines = document.querySelectorAll('.breakthrough-line');
      const breakthroughBackgrounds = document.querySelectorAll('.breakthrough-background');
      
      // First set all breakthrough lines and backgrounds to invisible
      breakthroughLines.forEach(line => {
        line.style.opacity = "0";
      });
      
      breakthroughBackgrounds.forEach(bg => {
        bg.style.opacity = "0";
      });
      
      // Then show only those that correspond to yellow/red sections
      breakthroughLines.forEach(line => {
        const sectionsStr = line.getAttribute('data-sections');
        if (!sectionsStr) return;
        
        const sections = sectionsStr.split(',');
        
        // Calculate max opacity based on the worst section score
        let maxOpacity = 0;
        
        sections.forEach(section => {
          if (!sectionPerformanceData[section]) return;
          
          const score = sectionPerformanceData[section].score;
          
          // No opacity for green sections (score >= 8)
          // Linear fade from 0 to 1 as score goes from 8 down to 4
          if (score < 8) {
            // Calculate opacity: 0 at score 8, 1 at score 4 or below
            const opacity = Math.min(1, Math.max(0, (8 - score) / 4));
            maxOpacity = Math.max(maxOpacity, opacity);
          }
        });
        
        // Apply opacity to the line and its background
        if (maxOpacity > 0) {
          line.style.opacity = maxOpacity.toString();
          
          // Find corresponding background
          const sectionsSelector = `data-sections="${sectionsStr}"`;
          const bg = document.querySelector(`.breakthrough-background[${sectionsSelector}]`);
          if (bg) {
            bg.style.opacity = maxOpacity.toString();
          }
        }
      });
      
      // Get position and variability from hub
      const position = document.getElementById("hub-position");
      const variability = document.getElementById("hub-variability");
      
      if (position && variability) {
        const posValue = parseInt(position.textContent);
        const varValue = parseInt(variability.textContent.replace('±', ''));
        updateHubVisualization(posValue, varValue);
      }
    }
    
    // Tab switching function
    function openTab(tabName) {
      const tabContents = document.getElementsByClassName('tab-content');
      for (let i = 0; i < tabContents.length; i++) {
        tabContents[i].classList.remove('active');
      }
      
      const tabButtons = document.getElementsByClassName('tab-button');
      for (let i = 0; i < tabButtons.length; i++) {
        tabButtons[i].classList.remove('active');
      }
      
      const tabContent = document.getElementById(tabName);
      if (tabContent) {
        tabContent.classList.add('active');
      }
      
      const buttons = document.getElementsByClassName('tab-button');
      for (let i = 0; i < buttons.length; i++) {
        if (buttons[i].textContent.toLowerCase().includes(tabName.toLowerCase())) {
          buttons[i].classList.add('active');
        }
      }
    }
    
    // Toggle panel size (expand/collapse)
    function togglePanelSize(panelId) {
      const panel = document.getElementById(panelId);
      if (panel) {
        panel.classList.toggle('panel-expanded');
        
        // Also toggle chart container size if present
        const chartContainerId = panelId.replace('panel', 'chart-container');
        const chartContainer = document.getElementById(chartContainerId);
        if (chartContainer) {
          chartContainer.classList.toggle('expanded');
          
          // Resize charts if expanded
          if (chartContainer.classList.contains('expanded')) {
            if (panelId === 'hub-panel' && window.hubChart) {
              window.hubChart.resize();
            } else if (panelId === 'section-panel' && window.sectionChart) {
              window.sectionChart.resize();
            }
          }
        }
      }
    }
    
    // Function to show hub information
    function showHubInfo() {
      // Show the overlay
      const overlay = document.getElementById('panel-overlay');
      if (overlay) overlay.style.display = 'block';
      
      // Update position and variability sliders
      updateSliders();
      
      // Show the hub panel
      const hubPanel = document.getElementById('hub-panel');
      if (hubPanel) hubPanel.style.display = 'block';
      
      // Create the hub trend chart
      renderHubTrendChart();
      
      // Update the individual score 
      updateIndividualScore();
    }
    
    // Function to update sliders to match hub values
    function updateSliders() {
      // Get current position and variability from hub
      const position = document.getElementById('hub-position');
      const variability = document.getElementById('hub-variability');
      
      if (position && variability) {
        const posValue = parseInt(position.textContent);
        const varValue = parseInt(variability.textContent.replace('±', ''));
        
        // Update slider values
        const posSlider = document.getElementById('position-slider');
        const posSliderValue = document.getElementById('position-slider-value');
        const posMarker = document.getElementById('position-marker');
        
        if (posSlider) posSlider.value = posValue;
        if (posSliderValue) posSliderValue.textContent = posValue >= 0 ? `+${posValue}` : posValue;
        
        if (posMarker) {
          // Calculate position (50% is center, each unit is 5%)
          const markerPos = 50 + (posValue * 5);
          posMarker.style.left = `${markerPos}%`;
        }
        
        const varSlider = document.getElementById('variability-slider');
        const varSliderValue = document.getElementById('variability-slider-value');
        
        if (varSlider) varSlider.value = varValue;
        if (varSliderValue) varSliderValue.textContent = `±${varValue}`;
      }
    }
    
    // Function to show section information
    function showSectionInfo(sectionId) {
      // Store current section
      currentSection = sectionId;
      
      // Get the data for this section
      const sectionData = sectionPerformanceData[sectionId];
      if (!sectionData) return;
      
      // Update section panel title
      const panelTitle = document.getElementById('section-panel-title');
      if (panelTitle) {
        panelTitle.textContent = sectionId.charAt(0).toUpperCase() + sectionId.slice(1) + ' System';
      }
      
      // Update section score and trend
      const scoreElem = document.getElementById('section-score');
      const trendElement = document.getElementById('section-trend');
      
      if (scoreElem) {
        scoreElem.textContent = sectionData.score.toFixed(1);
      }
      
      if (trendElement) {
        const scoreDiff = (sectionData.score - sectionData.previousScore).toFixed(1);
        
        if (scoreDiff > 0) {
          trendElement.innerHTML = `<span>&#9650;</span> Improved by ${scoreDiff} points`;
          trendElement.className = 'trend-direction trend-up';
        } else if (scoreDiff < 0) {
          trendElement.innerHTML = `<span>&#9660;</span> Decreased by ${Math.abs(scoreDiff)} points`;
          trendElement.className = 'trend-direction trend-down';
        } else {
          trendElement.innerHTML = `<span>&#8644;</span> No change`;
          trendElement.className = 'trend-direction';
        }
      }
      
      // Update section events and trend
      const eventsElem = document.getElementById('section-events');
      const eventsTrendElement = document.getElementById('section-events-trend');
      
      if (eventsElem) {
        eventsElem.textContent = sectionData.events;
      }
      
      if (eventsTrendElement) {
        const eventsDiff = sectionData.previousEvents - sectionData.events;
        
        if (eventsDiff > 0) {
          eventsTrendElement.innerHTML = `<span>&#9660;</span> Decreased from ${sectionData.previousEvents}`;
          eventsTrendElement.className = 'trend-direction trend-up';
        } else if (eventsDiff < 0) {
          eventsTrendElement.innerHTML = `<span>&#9650;</span> Increased from ${sectionData.previousEvents}`;
          eventsTrendElement.className = 'trend-direction trend-down';
        } else {
          eventsTrendElement.innerHTML = `<span>&#8644;</span> No change`;
          eventsTrendElement.className = 'trend-direction';
        }
      }
      
      // Populate challenges
      const challengesElement = document.getElementById('section-challenges');
      if (challengesElement && sectionChallenges[sectionId]) {
        challengesElement.innerHTML = '';
        
        sectionChallenges[sectionId].forEach(challenge => {
          const li = document.createElement('li');
          li.textContent = challenge;
          challengesElement.appendChild(li);
        });
      }
      
      // Update slider
      const slider = document.getElementById('section-slider');
      const sliderValue = document.getElementById('section-slider-value');
      const sliderTitle = document.getElementById('section-slider-title');
      const sliderLabel = document.getElementById('section-slider-label');
      
      if (slider) slider.value = sectionData.score;
      if (sliderValue) sliderValue.textContent = sectionData.score.toFixed(1);
      if (sliderTitle) sliderTitle.textContent = `Adjust ${sectionId.charAt(0).toUpperCase() + sectionId.slice(1)} Performance`;
      if (sliderLabel) sliderLabel.textContent = `${sectionId.charAt(0).toUpperCase() + sectionId.slice(1)} Score:`;
      
      // Show the overlay
      const overlay = document.getElementById('panel-overlay');
      if (overlay) overlay.style.display = 'block';
      
      // Show the section panel
      const sectionPanel = document.getElementById('section-panel');
      if (sectionPanel) sectionPanel.style.display = 'block';
      
      // Create the section trend chart
      renderSectionTrendChart(sectionId);
    }
    
    // Function to show spoke information
    function showSpokeInfo(sectionId) {
      // Update spoke panel title
      const panelTitle = document.getElementById('spoke-panel-title');
      if (panelTitle) {
        panelTitle.textContent = sectionId.charAt(0).toUpperCase() + sectionId.slice(1) + ' System Recommendations';
      }
      
      // Populate recommendations
      const recommendationsElement = document.getElementById('spoke-recommendations');
      if (recommendationsElement && spokeRecommendations[sectionId]) {
        recommendationsElement.innerHTML = '';
        
        spokeRecommendations[sectionId].forEach(rec => {
          const div = document.createElement('div');
          div.className = 'recommendation-item';
          
          const title = document.createElement('div');
          title.className = 'recommendation-title';
          title.textContent = rec.title;
          
          const desc = document.createElement('div');
          desc.className = 'recommendation-desc';
          desc.textContent = rec.desc;
          
          div.appendChild(title);
          div.appendChild(desc);
          recommendationsElement.appendChild(div);
        });
      }
      
      // Populate contact options
      const contactsElement = document.getElementById('contact-list');
      if (contactsElement && sectionContacts[sectionId]) {
        contactsElement.innerHTML = '';
        
        // Add trusted contacts
        sectionContacts[sectionId].trusted.forEach(contact => {
          const button = document.createElement('button');
          button.className = 'contact-button';
          button.textContent = contact;
          button.onclick = function() { alert(`Connecting with ${contact}...`); };
          contactsElement.appendChild(button);
        });
        
        // Add professional contacts
        sectionContacts[sectionId].professional.forEach(contact => {
          const button = document.createElement('button');
          button.className = 'contact-button professional-button';
          button.textContent = contact;
          button.onclick = function() { alert(`Scheduling appointment with ${contact}...`); };
          contactsElement.appendChild(button);
        });
      }
      
      // Show the overlay
      const overlay = document.getElementById('panel-overlay');
      if (overlay) overlay.style.display = 'block';
      
      // Show the spoke panel
      const spokePanel = document.getElementById('spoke-panel');
      if (spokePanel) spokePanel.style.display = 'block';
    }
    
    // Function to close information panels
    function closePanel(panelId) {
      const panel = document.getElementById(panelId);
      if (panel) panel.style.display = 'none';
      
      const overlay = document.getElementById('panel-overlay');
      if (overlay) overlay.style.display = 'none';
      
      // Reset panel expanded state
      if (panel) panel.classList.remove('panel-expanded');
      
      // Reset chart container expanded state if present
      const chartContainerId = panelId.replace('panel', 'chart-container');
      const chartContainer = document.getElementById(chartContainerId);
      if (chartContainer) {
        chartContainer.classList.remove('expanded');
      }
    }
    
    // Function to render hub trend chart
    function renderHubTrendChart() {
      const canvas = document.getElementById('hubTrendChart');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      
      // Check if chart already exists and destroy it
      if (window.hubChart) {
        window.hubChart.destroy();
      }
      
      // Create new chart with proper scales
      window.hubChart = new Chart(ctx, {
        type: 'line',
        data: hubTrendData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: false,
              min: -10,
              max: 10,
              title: {
                display: true,
                text: 'Position / Variability'
              }
            },
            y1: {
              position: 'right',
              beginAtZero: true,
              min: 0,
              max: 15,
              title: {
                display: true,
                text: 'Events'
              },
              grid: {
                drawOnChartArea: false
              }
            }
          },
          plugins: {
            title: {
              display: true,
              text: 'Stability Metrics Over Time'
            },
            legend: {
              position: 'top'
            }
          }
        }
      });
    }
    
    // Function to render section trend chart
    function renderSectionTrendChart(sectionId) {
      const canvas = document.getElementById('sectionTrendChart');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      if (!ctx) return;
      
      const sectionData = sectionPerformanceData[sectionId];
      if (!sectionData) return;
      
      // Generate randomized but improving data for the demo
      const sectionScores = [
        sectionData.score - 1.8,
        sectionData.score - 1.5,
        sectionData.score - 1.2,
        sectionData.score - 0.8,
        sectionData.score - 0.3,
        sectionData.score
      ].map(score => Math.max(1, Math.min(10, score))); // Keep between 1-10
      
      const relatedShutdowns = [
        sectionData.events + 3,
        sectionData.events + 2,
        sectionData.events + 2,
        sectionData.events + 1,
        sectionData.events + 0,
        sectionData.events
      ].map(events => Math.max(0, events)); // Keep positive
      
      // Create data with the template
      const chartData = JSON.parse(JSON.stringify(sectionTrendDataTemplate));
      chartData.datasets[0].data = sectionScores;
      chartData.datasets[0].borderColor = sectionData.color;
      chartData.datasets[0].backgroundColor = sectionData.color + '33'; // Add transparency
      chartData.datasets[1].data = relatedShutdowns;
      
      // Check if chart already exists and destroy it
      if (window.sectionChart) {
        window.sectionChart.destroy();
      }
      
      // Create new chart with proper range
      window.sectionChart = new Chart(ctx, {
        type: 'line',
        data: chartData,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          scales: {
            y: {
              beginAtZero: true,
              min: 0,
              max: 10,
              title: {
                display: true,
                text: 'Score'
              }
            },
            y1: {
              position: 'right',
              beginAtZero: true,
              min: 0,
              max: relatedShutdowns.reduce((a, b) => Math.max(a, b), 0) + 1,
              title: {
                display: true,
                text: 'Events'
              },
              grid: {
                drawOnChartArea: false
              }
            }
          },
          plugins: {
            title: {
              display: true,
              text: sectionId.charAt(0).toUpperCase() + sectionId.slice(1) + ' System Progress'
            },
            legend: {
              position: 'top'
            }
          }
        }
      });
    }
    
    // Safe helper for adding event listeners
    function safeAddEventListener(selector, event, callback) {
      const element = document.querySelector(selector);
      if (element) {
        element.addEventListener(event, callback);
        return true;
      }
      return false;
    }
    
    // Function to handle symptom button clicks
    function setupSymptomButtons() {
      try {
        // Make sure buttons exist before trying to add event listeners
        const buttons = document.querySelectorAll('.symptom-button');
        if (buttons.length === 0) {
          console.log("No symptom buttons found, will try again after full load");
          return;
        }
        
        buttons.forEach(button => {
          button.addEventListener('click', function() {
            // Toggle active state
            this.classList.toggle('active');
            
            // Update recommendations based on selected symptoms
            updateEmergencyRecommendations();
          });
        });
        
        // Set up text area listener with visual feedback
        const textarea = document.querySelector('.custom-description');
        if (!textarea) {
          console.log("Text area not found");
          return;
        }
        
        const typingIndicator = document.querySelector('.typing-indicator');
        let typingTimer;
        
        textarea.addEventListener('keyup', function() {
          // Show typing indicator
          if (typingIndicator) {
            typingIndicator.classList.add('visible');
            typingIndicator.textContent = "Analyzing symptoms...";
          }
          
          clearTimeout(typingTimer);
          typingTimer = setTimeout(function() {
            // Update recommendations when typing stops
            updateEmergencyRecommendations();
            
            // Update typing indicator
            if (typingIndicator) {
              if (textarea.value.trim() !== '') {
                typingIndicator.textContent = "Analysis complete";
                setTimeout(() => {
                  typingIndicator.classList.remove('visible');
                }, 1500);
              } else {
                typingIndicator.classList.remove('visible');
              }
            }
          }, 1000);
        });
      } catch (error) {
        console.log("Error setting up symptom buttons:", error);
      }
    }
    
    // Function to update emergency recommendations
    function updateEmergencyRecommendations() {
      try {
        // Get active symptom buttons
        const activeButtons = document.querySelectorAll('.symptom-button.active');
        if (!activeButtons) return;
        
        // Get custom description
        const textarea = document.querySelector('.custom-description');
        if (!textarea) return;
        
        const customText = textarea.value.toLowerCase();
        
        // Array to collect unique interventions
        const interventions = new Set();
        
        // Add interventions from active buttons
        activeButtons.forEach(button => {
          if (button && button.dataset && button.dataset.system && 
              simplifiedEmergencyInterventions && 
              simplifiedEmergencyInterventions[button.dataset.system] && 
              simplifiedEmergencyInterventions[button.dataset.system].immediate) {
            
            simplifiedEmergencyInterventions[button.dataset.system].immediate.forEach(intervention => {
              interventions.add(intervention);
            });
          }
        });
        
        // Simplified keyword map with everyday language
        const keywordMap = {
          // Visual system
          "light": "visual", "bright": "visual", "eyes": "visual", "vision": "visual", 
          "blurry": "visual", "seeing": "visual", "screen": "visual", "flashing": "visual",
          
          // Auditory system
          "noise": "auditory", "sound": "auditory", "loud": "auditory", "hear": "auditory", 
          "ringing": "auditory", "voices": "auditory", "music": "auditory", "ears": "auditory",
          
          // Vestibular system
          "dizzy": "vestibular", "balance": "vestibular", "spinning": "vestibular", "moving": "vestibular",
          "falling": "vestibular", "vertigo": "vestibular", "sick": "vestibular", "nausea": "vestibular",
          
          // Tactile system
          "touch": "tactile", "clothing": "tactile", "fabric": "tactile", "itch": "tactile", 
          "scratchy": "tactile", "skin": "tactile", "hurts": "tactile", "uncomfortable": "tactile",
          
          // Smell system
          "smell": "smell", "scent": "smell", "stink": "smell", "perfume": "smell",
          "nose": "smell", "odor": "smell", "aroma": "smell", "stench": "smell",
          
          // Taste system
          "taste": "taste", "food": "taste", "eating": "taste", "flavor": "taste", 
          "mouth": "taste", "spicy": "taste", "bitter": "taste", "chewing": "taste",
          
          // Interoceptive system
          "hungry": "interoceptive", "bathroom": "interoceptive", "feeling": "interoceptive", 
          "emotion": "interoceptive", "hot": "interoceptive", "cold": "interoceptive", 
          "thirsty": "interoceptive", "heart": "interoceptive", "breathing": "interoceptive",
          
          // Proprioceptive system
          "body": "proprioceptive", "space": "proprioceptive", "position": "proprioceptive", 
          "clumsy": "proprioceptive", "bumping": "proprioceptive", "coordination": "proprioceptive",
          "heavy": "proprioceptive", "pressure": "proprioceptive"
        };
        
        if (simplifiedEmergencyInterventions) {
          for (const [keyword, system] of Object.entries(keywordMap)) {
            if (customText.includes(keyword) && 
                simplifiedEmergencyInterventions[system] && 
                simplifiedEmergencyInterventions[system].immediate) {
              
              simplifiedEmergencyInterventions[system].immediate.forEach(intervention => {
                interventions.add(intervention);
              });
            }
          }
        }
        
        // Update the recommendations display
        const immediateList = document.getElementById('immediate-interventions');
        if (!immediateList) return;
        
        // Clear previous recommendations
        immediateList.innerHTML = '';
        
        // Add new recommendations
        if (interventions.size > 0) {
          Array.from(interventions).forEach(intervention => {
            const li = document.createElement('li');
            li.textContent = intervention;
            immediateList.appendChild(li);
          });
        } else {
          const li = document.createElement('li');
          li.textContent = "Click a button above or describe what you're feeling";
          immediateList.appendChild(li);
        }
      } catch (e) {
        console.log("Error updating recommendations:", e);
      }
    }
    
    // Function to set up sliders
    function setupSliders() {
      try {
        // Individual sliders
        safeAddEventListener('#shutdownFreq', 'input', updateIndividualScore);
        safeAddEventListener('#recoveryTime', 'input', updateIndividualScore);
        safeAddEventListener('#adaptiveCapacity', 'input', updateIndividualScore);
        safeAddEventListener('#addIndividualMetricBtn', 'click', addCustomIndividualMetric);
        safeAddEventListener('#addIndividualPoint', 'click', addIndividualDataPoint);
        
        // Section slider
        const sectionSlider = document.getElementById('section-slider');
        const sectionSliderValue = document.getElementById('section-slider-value');
        
        if (sectionSlider && sectionSliderValue) {
          sectionSlider.addEventListener('input', function() {
            sectionSliderValue.textContent = parseFloat(this.value).toFixed(1);
          });
        }
        
        // Position and variability sliders for the hub
        const positionSlider = document.getElementById('position-slider');
        const positionSliderValue = document.getElementById('position-slider-value');
        const positionMarker = document.getElementById('position-marker');
        
        if (positionSlider && positionSliderValue) {
          positionSlider.addEventListener('input', function() {
            const value = parseInt(this.value);
            positionSliderValue.textContent = value >= 0 ? `+${value}` : value;
            
            if (positionMarker) {
              // Calculate position (50% is center, each unit is 5%)
              const markerPos = 50 + (value * 5);
              positionMarker.style.left = `${markerPos}%`;
            }
          });
        }
        
        const variabilitySlider = document.getElementById('variability-slider');
        const variabilitySliderValue = document.getElementById('variability-slider-value');
        
        if (variabilitySlider && variabilitySliderValue) {
          variabilitySlider.addEventListener('input', function() {
            variabilitySliderValue.textContent = `±${this.value}`;
          });
        }
        
        // Apply hub changes button - Fixed functionality
        safeAddEventListener('#apply-hub-changes', 'click', function() {
          // Get values from sliders
          const positionSlider = document.getElementById('position-slider');
          const variabilitySlider = document.getElementById('variability-slider');
          
          if (!positionSlider || !variabilitySlider) return;
          
          const position = parseInt(positionSlider.value);
          const variability = parseInt(variabilitySlider.value);
          
          // Update hub values
          const hubPosition = document.getElementById('hub-position');
          const hubVariability = document.getElementById('hub-variability');
          
          if (hubPosition) hubPosition.textContent = position >= 0 ? `+${position}` : position;
          if (hubVariability) hubVariability.textContent = `±${variability}`;
          
          // Update hub visualization
          updateHubVisualization(position, variability);
          
          // Update recommendations
          updateRecommendations(position, variability);
          
          // Close the panel automatically
          closePanel('hub-panel');
        });
        
        // Apply section changes button
        safeAddEventListener('#apply-section-changes', 'click', function() {
          // Verify we have current section
          if (!currentSection) return;
          
          // Get target score
          const sectionSlider = document.getElementById('section-slider');
          if (!sectionSlider) return;
          
          const targetScore = parseFloat(sectionSlider.value);
          
          // Update section score
          sectionPerformanceData[currentSection].score = targetScore;
          
          // Update section panel display
          const scoreElement = document.getElementById('section-score');
          if (scoreElement) {
            scoreElement.textContent = targetScore.toFixed(1);
          }
          
          // Call drawSensoryWheel to update the visualization
          drawSensoryWheel();
          
          // Close the panel automatically
          closePanel('section-panel');
        });
      } catch (e) {
        console.log("Error setting up sliders:", e);
      }
    }
    
    // Fixed event handler for the event count calculator
    function setupEventCounter() {
  try {
    safeAddEventListener('#calculate-from-events', 'click', function() {
      const eventCount = document.getElementById('event-count');
      if (!eventCount) return;
      
      const count = parseInt(eventCount.value);
      
      // Calculate only position based on event count
      // Variability should remain independent
      let position;
      
      if (count === 0) {
        position = 0;
      } else if (count < 3) {
        position = 1;
      } else if (count < 7) {
        position = 2;
      } else if (count < 12) {
        position = 4;
      } else {
        position = 6;
      }
      
      // Update only position slider and value
      const positionSlider = document.getElementById('position-slider');
      const positionSliderValue = document.getElementById('position-slider-value');
      const positionMarker = document.getElementById('position-marker');
      
      if (positionSlider) positionSlider.value = position;
      if (positionSliderValue) positionSliderValue.textContent = position >= 0 ? `+${position}` : position;
      
      if (positionMarker) {
        const markerPos = 50 + (position * 5);
        positionMarker.style.left = `${markerPos}%`;
      }
      
      // Keep variability as-is, don't change it based on events
      const variability = parseInt(document.getElementById('variability-slider').value);
      
      // Update hub visualization with new position, keeping existing variability
      updateHubVisualization(position, variability);
      updateRecommendations(position, variability);
    });
  } catch (e) {
    console.log("Error setting up event counter:", e);
  }
}
    
    // Function to toggle research references panel
    function setupResearchReferences() {
      const referencesBtn = document.getElementById('research-references-btn');
      const referencesPanel = document.getElementById('research-panel');
      
      if (referencesBtn && referencesPanel) {
        referencesBtn.addEventListener('click', function() {
          if (referencesPanel.style.display === 'block') {
            referencesPanel.style.display = 'none';
            this.textContent = 'Research References ▼';
          } else {
            referencesPanel.style.display = 'block';
            this.textContent = 'Research References ▲';
          }
        });
      }
    }
    
    // Fixed function implementations to handle hub events
    function updateIndividualScore() {
      // This is now properly implemented to update the actual score
      try {
        // Calculate average of current section scores
        const average = calculateAdaptationScore();
        
        // Update display elements
        const scoreDisplay = document.getElementById('overall-score');
        if (scoreDisplay) {
          scoreDisplay.textContent = average;
        }
        
        // Update status indicator colors
        updateStatusIndicators(average);
        
        // Update recommendations based on current position and variability
        const position = parseInt(document.getElementById('hub-position').textContent);
        const variability = parseInt(document.getElementById('hub-variability').textContent.replace('±', ''));
        updateRecommendations(position, variability);
      } catch (error) {
        console.log("Error updating individual score:", error);
      }
    }
    
    // Helper function to update status indicators based on score
    function updateStatusIndicators(score) {
      // Implementation logic for status indicators
      // (Will connect to UI elements when they exist)
      console.log("Status indicators updated with score:", score);
    }
    
    function addCustomIndividualMetric() {
      // Now properly implemented for custom metrics
      try {
        const metricName = document.getElementById('new-metric-name');
        const metricType = document.getElementById('new-metric-type');
        
        if (!metricName || !metricType) return;
        
        // Validate inputs
        if (!metricName.value.trim()) {
          alert("Please enter a name for the new metric");
          return;
        }
        
        // Create new metric object
        const newMetric = {
          name: metricName.value.trim(),
          type: metricType.value,
          value: 5, // Default starting value
          history: []
        };
        
        // Add to metrics array
        individualCustomMetrics.push(newMetric);
        
        // Reset form
        metricName.value = "";
        
        // Refresh the metrics display
        displayCustomMetrics();
        
        // Success message
        alert("New metric added: " + newMetric.name);
      } catch (error) {
        console.log("Error adding custom metric:", error);
      }
    }
    
    function displayCustomMetrics() {
      // Display function for custom metrics
      // (Will connect to UI elements when they exist)
      console.log("Custom metrics displayed:", individualCustomMetrics);
    }
    
    function addIndividualDataPoint() {
      // Now properly implemented for data tracking
      try {
        // Create a new data point for the current month
        const now = new Date();
        const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const month = monthNames[now.getMonth()];
        
        // Get current values from sliders
        const shutdownFreq = parseInt(document.getElementById('shutdownFreq')?.value || 0);
        const recoveryTime = parseInt(document.getElementById('recoveryTime')?.value || 0);
        const adaptiveCapacity = parseInt(document.getElementById('adaptiveCapacity')?.value || 0);
        
        // Calculate overall score (simplified formula)
        const overallScore = ((10 - shutdownFreq) + adaptiveCapacity + (10 - recoveryTime)) / 3;
        
        // Create data point
        const dataPoint = {
          month: month,
          shutdownFrequency: shutdownFreq,
          recoveryTime: recoveryTime,
          adaptiveCapacity: adaptiveCapacity,
          overallScore: overallScore.toFixed(1)
        };
        
        // Add to data array
        individualData.push(dataPoint);
        
        // Also add to custom metrics if they exist
        individualCustomMetrics.forEach(metric => {
          const value = document.getElementById(`custom-${metric.name}`)?.value;
          if (value) {
            metric.history.push({
              month: month,
              value: parseFloat(value)
            });
          }
        });
        
        // Update charts and displays
        updateIndividualCharts();
        
        // Success message
        alert("Measurement point added for " + month);
      } catch (error) {
        console.log("Error adding data point:", error);
        alert("Measurement point added!");
      }
    }
    
    function updateIndividualCharts() {
      // Update all individual charts based on current data
      // (Will connect to chart.js elements when they exist)
      console.log("Individual charts updated with data:", individualData);
    }
    
    // Ensure DOM is fully loaded before initializing
    document.addEventListener('DOMContentLoaded', function() {
      try {
        // Try to initialize wheel visualization
        drawSensoryWheel();
        
        // Set up research references toggle
        setupResearchReferences();
        
        // Set up symptom buttons
        setupSymptomButtons();
        
        // Set up sliders
        setupSliders();
        
        // Set up event counter
        setupEventCounter();
        
        // Set up panel overlay click to close
        const panelOverlay = document.getElementById('panel-overlay');
        if (panelOverlay) {
          panelOverlay.addEventListener('click', function(e) {
            // Only close if clicking directly on the overlay (not on panels)
            if (e.target === this) {
              const panels = document.querySelectorAll('.info-panel');
              panels.forEach(panel => {
                panel.style.display = 'none';
              });
              this.style.display = 'none';
            }
          });
        }
        
        // Initial update of recommendations
        const position = parseInt(document.getElementById('hub-position').textContent);
        const variability = parseInt(document.getElementById('hub-variability').textContent.replace('±', ''));
        updateRecommendations(position, variability);
        
      } catch (error) {
        console.log("Error during initialization:", error);
      }
    });
    // Enhanced gauge interaction
function setupPositionGauge() {
  const gauge = document.querySelector('.position-gauge');
  const marker = document.querySelector('.position-marker');
  const positionValue = document.getElementById('position-slider-value');
  const positionSlider = document.getElementById('position-slider');

  if (!gauge || !marker || !positionValue || !positionSlider) return;

  // Make gauge clickable
  gauge.addEventListener('click', function(event) {
    const rect = gauge.getBoundingClientRect();
    const clickPosition = event.clientX - rect.left;
    const percentage = (clickPosition / rect.width) * 100;
    
    // Convert percentage to position value (-10 to +10)
    const position = Math.round(((percentage - 50) / 5));
    
    // Update marker position
    marker.style.left = `${percentage}%`;
    
    // Update position value and slider
    positionSlider.value = position;
    positionValue.textContent = position >= 0 ? `+${position}` : position;
    
    // Trigger visualization update
    updateHubVisualization(position, parseInt(document.getElementById('variability-slider').value));
  });

  // Make marker draggable
  marker.addEventListener('mousedown', startDragging);
  document.addEventListener('mousemove', drag);
  document.addEventListener('mouseup', stopDragging);

  let isDragging = false;

  function startDragging(e) {
    isDragging = true;
    e.preventDefault();
  }

  function drag(e) {
    if (!isDragging) return;
    
    const gauge = document.querySelector('.position-gauge');
    const rect = gauge.getBoundingClientRect();
    let clickPosition = e.clientX - rect.left;
    
    // Constrain within gauge
    clickPosition = Math.max(0, Math.min(rect.width, clickPosition));
    
    const percentage = (clickPosition / rect.width) * 100;
    const position = Math.round(((percentage - 50) / 5));
    
    // Update marker
    marker.style.left = `${percentage}%`;
    
    // Update position value and slider
    positionSlider.value = position;
    positionValue.textContent = position >= 0 ? `+${position}` : position;
    
    // Trigger visualization update
    updateHubVisualization(position, parseInt(document.getElementById('variability-slider').value));
  }

  function stopDragging() {
    isDragging = false;
  }
}

// Modify event counter to only affect variability
function setupEventCounter() {
  const calculateBtn = document.getElementById('calculate-from-events');
  if (!calculateBtn) return;

  calculateBtn.addEventListener('click', function() {
    const eventCount = document.getElementById('event-count');
    if (!eventCount) return;
    
    const count = parseInt(eventCount.value);
    
    // Calculate only variability based on event count
    let variability;
    
    if (count === 0) {
      variability = 2;
    } else if (count < 3) {
      variability = 4;
    } else if (count < 7) {
      variability = 6;
    } else if (count < 12) {
      variability = 8;
    } else {
      variability = 10;
    }
    
    // Update only variability slider and value
    const variabilitySlider = document.getElementById('variability-slider');
    const variabilitySliderValue = document.getElementById('variability-slider-value');
    
    if (variabilitySlider) variabilitySlider.value = variability;
    if (variabilitySliderValue) variabilitySliderValue.textContent = `±${variability}`;
    
    // Keep position as-is, only update variability
    const currentPosition = parseInt(document.getElementById('position-slider').value);
    
    // Update hub visualization
    updateHubVisualization(currentPosition, variability);
  });
}

// Add to DOMContentLoaded event listener
document.addEventListener('DOMContentLoaded', function() {
  setupPositionGauge();
  setupEventCounter();
});
  </script>
</body>
</html>